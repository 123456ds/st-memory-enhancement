v2.0.57:
- **最终综合修复：彻底解决独立填表的数据流、执行与序列化问题**
  - **问题 1 (数据源与保存不一致):** 在整个独立填表流程中，存在多个数据实例不一致的风险点。`separateTableUpdate.js` 获取操作数据源时不够稳定；`index.js` 在执行完指令后，又从一个全新的实例中保存数据。这导致了操作在过时或错误的数据上进行，并且保存的也不是经过修改的实例，是“内容消失”和“宏失效”的根本原因。
  - **实现方式 1:**
    - **1. 统一数据源获取:** 在 `scripts/runtime/separateTableUpdate.js` 中，强制使用 `BASE.getLastSheetsPiece()` 来获取 `referencePiece`，确保操作总是基于包含有效表格的最新聊天记录。
    - **2. 统一数据保存目标:** 在 `index.js` 的 `executeTableEditActions` 函数中，移除了重新获取 `savePiece` 的逻辑，确保所有 `sheet.save()` 操作都将修改持久化到传入的、且被修改过的同一个 `referencePiece` 实例上，保证了数据流的原子性。

  - **问题 2 (数据污染与序列化错误):** AI返回的数据中可能包含无效的转义字符（如 `\'`），这些字符在被存入单元格后，会导致 `JSON.stringify`（被 `GET_ALL_TABLES_JSON` 等宏使用）生成格式错误的JSON字符串，从而引发下游的 `JSON.parse` 错误。
  - **实现方式 2:**
    - **1. 新增清洗工具:** 在 `index.js` 中增加了 `fixUnescapedSingleQuotes` 函数，用于递归清理数据对象中的无效转义字符。
    - **2. 执行前清洗:** 在 `executeAction` 函数中，对所有即将被写入单元格的数据（`action.data`）调用此清洗函数，从源头上杜绝了脏数据的产生。
  
  - **结果:** 通过对数据流的“获取 -> 修改 -> 保存”全链路进行闭环，并增加对上游（AI）数据的清洗环节，彻底解决了独立填表功能中所有已知的数据不一致、执行错误、内容丢失及宏失效问题，确保了功能的端到端健壮性。
  - **受影响文件:**
    - `index.js`
    - `scripts/runtime/separateTableUpdate.js`
v2.0.56:
- **核心修复：解决了独立填表功能中数据丢失和填表为空的根本问题**
  - **问题 1 (数据丢失):** “独立填表”功能在获取操作所依据的表格数据时，错误地使用了 `BASE.getReferencePiece()`，这可能导致获取到的是一个过时的、非当前的表格实例。所有基于这个旧实例的修改在UI刷新后都会丢失，因为UI显示的是最新的、从未被修改过的表格。
  - **实现方式 1:**
    - **1. 修正数据源获取:** 修改了 `scripts/runtime/separateTableUpdate.js` 中的 `manualSummaryChat` 函数。
    - **2. 采用最新实例:** 不再调用 `BASE.getReferencePiece()`，而是通过 `USER.getChatPiece()` 来获取当前激活的、最新的聊天片段（piece）作为操作的 `referencePiece`。
    - **结果 1:** 此修改确保了“独立填表”的所有操作都基于用户当前看到的、最权威的数据版本，彻底解决了因数据源不一致导致的内容“假性”修改和最终丢失的问题。

  - **问题 2 (填表为空/不填表):** 在执行表格更新操作时，位于 `core/table/oldTableActions.js` 中的 `handleCellValue` 函数存在逻辑缺陷。它无法正确处理AI返回的 `null` 或 `undefined` 值，一律将其转换为空字符串 `''`，导致单元格被清空。此外，该文件内包含了冗余的、已失效的新旧系统判断逻辑。
  - **实现方式 2:**
    - **1. 重构表格操作:** 对 `core/table/oldTableActions.js` 进行了整体重写。
    - **2. 简化逻辑:** 移除了所有关于新旧表格系统（`Sheet` vs `table`）的判断分支，统一为直接操作普通表格对象的健壮逻辑。
    - **3. 强化值处理:** 重写了 `handleCellValue` 函数，使其能够明确、正确地处理 `null` 和 `undefined`（统一转换为空字符串 `''`），并能稳健地处理数字、布尔值等其他数据类型，防止了无效或非预期的值被填入表格。
    - **结果 2:** 从根本上解决了因AI返回空值或非标数据而导致的“填表为空”或“不填表”的问题，大幅提升了填表操作的稳定性和准确性。
  - **受影响文件:**
    - `scripts/runtime/separateTableUpdate.js`
    - `core/table/oldTableActions.js`
v2.0.55:
- **最终修复：通过统一数据源获取方式，彻底解决实例不一致问题**
  - **问题:** 经过反复排查，确认问题的根源在于系统的不同部分获取了不同的表格（`Sheet`）对象实例。`separateTableUpdate.js` 和 `absoluteRefresh.js` 之间传递的 `latestSheets` 实例，在经过 `reloadCurrentChat()` 等操作后，与系统内核中最新的实例脱钩，导致数据不同步。
  - **实现方式:**
    - **1. 解耦函数依赖:** 修改了 `absoluteRefresh.js` 中的 `executeIncrementalUpdateFromSummary` 函数，移除了 `latestSheets` 参数。
    - **2. 即时获取数据源:** `executeIncrementalUpdateFromSummary` 现在不再依赖外部传入的表格实例，而是在其函数内部、执行所有AI指令之前的那一刻，通过 `BASE.getChatSheets()` 方法主动获取当前最新的、唯一的表格实例。
    - **3. 清理调用链:** 相应地，修改了 `separateTableUpdate.js` 中对 `executeIncrementalUpdateFromSummary` 的调用，不再传递表格实例参数。
  - **结果:** 该方案确保了AI指令的**执行者**（`absoluteRefresh.js`）总是操作最权威、最新的数据源，彻底杜绝了因实例不一致导致的数据不同步和“无效索引”等连锁错误。这是针对此问题的最终、最根本的修复。
  - **受影响文件:**
    - `scripts/runtime/absoluteRefresh.js`
    - `scripts/runtime/separateTableUpdate.js`
