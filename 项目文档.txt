v2.0.62:
- **核心修复：解决自定义API设置刷新后失效的问题**
  - **问题:** 用户在自定义API设置页面输入的URL、密钥、模型名称、代理地址和代理密钥等信息，在页面刷新后会全部丢失。
  - **根本原因:** 在 `scripts/settings/userExtensionSetting.js` 文件中，相关的输入事件监听器只将用户的输入更新到了内存中的 `USER.IMPORTANT_USER_PRIVACY_DATA` 对象，但没有调用 `USER.saveSettings()` 方法将这些更改持久化保存。
  - **实现方式:**
    - **1. 修改设置保存逻辑:** 对 `scripts/settings/userExtensionSetting.js` 文件中处理以下控件的事件监听器进行了修改：
        - `custom_api_url` (API URL 输入框)
        - `custom_api_key` (API Key 输入框)
        - `custom_model_name` (模型名称 输入框)
        - `model_selector` (模型下拉选择器)
        - `table_proxy_address` (代理地址 输入框)
        - `table_proxy_key` (代理密钥 输入框)
    - **2. 增加持久化调用:** 在上述每个事件监听器中，当用户输入或选择发生变化并更新到内存对象后，立即增加了 `USER.saveSettings && USER.saveSettings();` 的调用。
  - **结果:** 用户的自定义API设置现在可以被正确地实时保存。刷新页面后，所有设置项将保持不变，彻底解决了数据丢失问题，提升了用户体验的连续性和可靠性。
  - **受影响文件:**
    - `scripts/settings/userExtensionSetting.js`

v2.0.61:
- **功能增强：优化分步填表确认流程**
  - **问题:** “分步填表”功能的确认提示框选项不够灵活，用户希望有更精细的控制。
  - **实现方式:**
    - **1. 改造确认弹窗组件:** 在 `components/popupConfirm.js` 中，对 `newPopupConfirm` 组件进行了扩展。
        - 增加了一个新的状态 `alwaysConfirmPopups`，用于在当前会话中记录“总是确认”的弹窗。
        - 增加了新的参数 `alwaysConfirmText`，用于创建“一直选是”按钮。该按钮会触发一个新事件 `'always_confirm_selected'`，将弹窗ID添加到 `alwaysConfirmPopups` 中。
        - `newPopupConfirm` 现在会检查 `alwaysConfirmPopups` 状态，如果命中，则直接返回 `true`，实现“会话内自动确认”的效果，但弹窗本身依然会显示，允许用户覆盖选择。
    - **2. 更新调用逻辑:** 在 `scripts/runtime/separateTableUpdate.js` 中，修改了对 `newPopupConfirm` 的调用。
        - 将原有的 `dontRemindText`（永久禁用）的按钮文本从“一直选是”修改为“不再提示”。
        - 新增了 `alwaysConfirmText` 参数，值为“一直选是”，从而在界面上增加了这个新选项。
  - **结果:** 用户现在对“分步填表”的确认流程有了更细致的控制，可以选择“本次执行”、“取消”、“会话内一直执行”或“永久不再提示”，提升了用户体验。
  - **受影响文件:**
    - `components/popupConfirm.js`
    - `scripts/runtime/separateTableUpdate.js`

v2.0.60:
- **配置调整：Deepseek API 上下文限制回退**
  - **问题:** Deepseek API 的默认上下文限制（`max_tokens`）被设置为一个较大的值（20000+），可能导致性能问题或与API的实际限制不符。
  - **实现方式:**
    - **1. 修改API服务:** 在 `services/llmApi.js` 文件中，将 `max_tokens` 的默认值从 `63000`（先前由20000调整而来）回退到 `8192`。
  - **结果:** 恢复了更稳定、更兼容的API上下文限制，以确保服务的正常运行。
  - **受影响文件:**
    - `services/llmApi.js`

v2.0.59:
- **核心逻辑重构与最终修复：统一数据源并增强宏健壮性**
  - **问题:** 经过多轮修复，宏导出功能在处理包含特殊字符或`null`/`undefined`值的单元格时，仍会偶尔生成无效JSON，导致下游解析失败。
  - **根本原因:** `JSON.stringify` 在处理一个包含非纯字符串元素的数组时，其行为可能不符合预期（例如 `null` 会被转为 `"null"` 字符串，`undefined` 会被转为 `null`），这与手动拼接字符串的逻辑冲突，导致最终的JSON格式错误。
  - **实现方式 (最终修复方案):**
    - **1. 数据类型净化 (治本):** 在 `scripts/settings/standaloneAPI.js` 的 `ext_exportAllTablesAsJson` 函数中，采用了最稳妥的数据清洗方案。在序列化之前，通过 `rawContent.map(row => row.map(cell => String(cell ?? '')))` 强制将二维数组中的每一个单元格都转换为字符串类型。`null` 和 `undefined` 被安全地转换为空字符串 `''`。
    - **2. 依赖标准序列化:** 在确保了输入数据源是纯净的字符串数组后，程序可以放心地使用标准的 `JSON.stringify` 来序列化整个数据对象，这是最可靠且无副作用的做法。
    - **3. 统一数据源逻辑:** 保留了 `absoluteRefresh.js` 和 `separateTableUpdate.js` 中所有填表功能都以“上一层”表格为基础的统一逻辑。
    - **4. 保留整页刷新:** 保留了 `reloadCurrentChat()` 作为最终的数据同步方式，确保UI和所有组件的绝对一致性。
  - **结果:** 通过在导出数据的最源头进行严格的数据类型净化，彻底解决了所有已知的数据污染和JSON格式错误问题。结合统一的数据源逻辑和可靠的页面刷新机制，插件的稳定性和可预测性达到了最终形态。
  - **受影响文件:**
    - `scripts/settings/standaloneAPI.js`
    - `scripts/runtime/absoluteRefresh.js`
    - `scripts/runtime/separateTableUpdate.js`

v2.0.58:
- **功能增强：独立填表（原分步填表）上下文选择**
  - **问题:** “独立填表”功能原先默认使用最新的AI回复作为上下文（`$1`），缺乏灵活性。
  - **实现方式:**
    - **1. 新增UI控件:** 在 `assets/templates/index.html` 的“立即填表”按钮旁，增加了一个数字输入框 `separateReadContextLayers`，允许用户自定义作为上下文的最新AI回复数量。
    - **2. 修改核心逻辑:** 在 `scripts/runtime/absoluteRefresh.js` 的 `executeIncrementalUpdateFromSummary` 函数中，修改了占位符的处理逻辑：
        - 从新的输入框中读取用户设定的层数。
        - 调用 `getRecentChatHistory` 函数，根据设定的层数获取相应数量的最新AI回复，并将其赋值给 `$1` 占位符作为上下文。
        - 将原先需要处理的聊天记录（`chatToBeUsed`）改由 `$2` 占位符传递。
    - **3. 持久化设置:** 在 `scripts/settings/userExtensionSetting.js` 中，为新的输入框添加了事件监听，确保用户设置的层数值能够被正确保存和加载。
  - **结果:** 用户现在可以灵活地控制“独立填表”时使用的上下文范围，提升了该功能的可用性和精确度。
  - **受影响文件:**
    - `assets/templates/index.html`
    - `scripts/runtime/absoluteRefresh.js`
    - `scripts/settings/userExtensionSetting.js`

v2.0.57:
- **最终综合修复：彻底解决独立填表的数据流、执行与序列化问题**
  - **问题 1 (数据源与保存不一致):** 在整个独立填表流程中，存在多个数据实例不一致的风险点。`separateTableUpdate.js` 获取操作数据源时不够稳定；`index.js` 在执行完指令后，又从一个全新的实例中保存数据。这导致了操作在过时或错误的数据上进行，并且保存的也不是经过修改的实例，是“内容消失”和“宏失效”的根本原因。
  - **实现方式 1:**
    - **1. 统一数据源获取:** 在 `scripts/runtime/separateTableUpdate.js` 中，强制使用 `BASE.getLastSheetsPiece()` 来获取 `referencePiece`，确保操作总是基于包含有效表格的最新聊天记录。
    - **2. 统一数据保存目标:** 在 `index.js` 的 `executeTableEditActions` 函数中，移除了重新获取 `savePiece` 的逻辑，确保所有 `sheet.save()` 操作都将修改持久化到传入的、且被修改过的同一个 `referencePiece` 实例上，保证了数据流的原子性。

  - **问题 2 (数据污染与序列化错误):** AI返回的数据中可能包含无效的转义字符（如 `\'`），这些字符在被存入单元格后，会导致 `JSON.stringify`（被 `GET_ALL_TABLES_JSON` 等宏使用）生成格式错误的JSON字符串，从而引发下游的 `JSON.parse` 错误。
  - **实现方式 2:**
    - **1. 新增清洗工具:** 在 `index.js` 中增加了 `fixUnescapedSingleQuotes` 函数，用于递归清理数据对象中的无效转义字符。
    - **2. 执行前清洗:** 在 `executeAction` 函数中，对所有即将被写入单元格的数据（`action.data`）调用此清洗函数，从源头上杜绝了脏数据的产生。
  
  - **结果:** 通过对数据流的“获取 -> 修改 -> 保存”全链路进行闭环，并增加对上游（AI）数据的清洗环节，彻底解决了独立填表功能中所有已知的数据不一致、执行错误、内容丢失及宏失效问题，确保了功能的端到端健壮性。
  - **受影响文件:**
    - `index.js`
    - `scripts/runtime/separateTableUpdate.js`
v2.0.56:
- **核心修复：解决了独立填表功能中数据丢失和填表为空的根本问题**
  - **问题 1 (数据丢失):** “独立填表”功能在获取操作所依据的表格数据时，错误地使用了 `BASE.getReferencePiece()`，这可能导致获取到的是一个过时的、非当前的表格实例。所有基于这个旧实例的修改在UI刷新后都会丢失，因为UI显示的是最新的、从未被修改过的表格。
  - **实现方式 1:**
    - **1. 修正数据源获取:** 修改了 `scripts/runtime/separateTableUpdate.js` 中的 `manualSummaryChat` 函数。
    - **2. 采用最新实例:** 不再调用 `BASE.getReferencePiece()`，而是通过 `USER.getChatPiece()` 来获取当前激活的、最新的聊天片段（piece）作为操作的 `referencePiece`。
    - **结果 1:** 此修改确保了“独立填表”的所有操作都基于用户当前看到的、最权威的数据版本，彻底解决了因数据源不一致导致的内容“假性”修改和最终丢失的问题。

  - **问题 2 (填表为空/不填表):** 在执行表格更新操作时，位于 `core/table/oldTableActions.js` 中的 `handleCellValue` 函数存在逻辑缺陷。它无法正确处理AI返回的 `null` 或 `undefined` 值，一律将其转换为空字符串 `''`，导致单元格被清空。此外，该文件内包含了冗余的、已失效的新旧系统判断逻辑。
  - **实现方式 2:**
    - **1. 重构表格操作:** 对 `core/table/oldTableActions.js` 进行了整体重写。
    - **2. 简化逻辑:** 移除了所有关于新旧表格系统（`Sheet` vs `table`）的判断分支，统一为直接操作普通表格对象的健壮逻辑。
    - **3. 强化值处理:** 重写了 `handleCellValue` 函数，使其能够明确、正确地处理 `null` 和 `undefined`（统一转换为空字符串 `''`），并能稳健地处理数字、布尔值等其他数据类型，防止了无效或非预期的值被填入表格。
    - **结果 2:** 从根本上解决了因AI返回空值或非标数据而导致的“填表为空”或“不填表”的问题，大幅提升了填表操作的稳定性和准确性。
  - **受影响文件:**
    - `scripts/runtime/separateTableUpdate.js`
    - `core/table/oldTableActions.js`
v2.0.55:
- **最终修复：通过统一数据源获取方式，彻底解决实例不一致问题**
  - **问题:** 经过反复排查，确认问题的根源在于系统的不同部分获取了不同的表格（`Sheet`）对象实例。`separateTableUpdate.js` 和 `absoluteRefresh.js` 之间传递的 `latestSheets` 实例，在经过 `reloadCurrentChat()` 等操作后，与系统内核中最新的实例脱钩，导致数据不同步。
  - **实现方式:**
    - **1. 解耦函数依赖:** 修改了 `absoluteRefresh.js` 中的 `executeIncrementalUpdateFromSummary` 函数，移除了 `latestSheets` 参数。
    - **2. 即时获取数据源:** `executeIncrementalUpdateFromSummary` 现在不再依赖外部传入的表格实例，而是在其函数内部、执行所有AI指令之前的那一刻，通过 `BASE.getChatSheets()` 方法主动获取当前最新的、唯一的表格实例。
    - **3. 清理调用链:** 相应地，修改了 `separateTableUpdate.js` 中对 `executeIncrementalUpdateFromSummary` 的调用，不再传递表格实例参数。
  - **结果:** 该方案确保了AI指令的**执行者**（`absoluteRefresh.js`）总是操作最权威、最新的数据源，彻底杜绝了因实例不一致导致的数据不同步和“无效索引”等连锁错误。这是针对此问题的最终、最根本的修复。
  - **受影响文件:**
    - `scripts/runtime/absoluteRefresh.js`
    - `scripts/runtime/separateTableUpdate.js`
